#include <iostream>
#include <string>
#include <vector>
#include <tuple>
#include <queue>
#include <windows.h>

// Тип значений о корректности выполнения функции
typedef unsigned int errtype;

// Тип значений идентификационных кодов
typedef unsigned int idtype;

// Перечисление спецификаций цвета выводимого текста в консоли 
enum Colour : WORD {
    BLACK = 0,
    DARKBLUE = FOREGROUND_BLUE,
    DARKGREEN = FOREGROUND_GREEN,
    DARKCYAN = FOREGROUND_GREEN | FOREGROUND_BLUE,
    DARKRED = FOREGROUND_RED,
    DARKMAGENTA = FOREGROUND_RED | FOREGROUND_BLUE,
    DARKYELLOW = FOREGROUND_RED | FOREGROUND_GREEN,
    DARKGRAY = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE,
    GRAY = FOREGROUND_INTENSITY,
    BLUE = FOREGROUND_INTENSITY | FOREGROUND_BLUE,
    GREEN = FOREGROUND_INTENSITY | FOREGROUND_GREEN,
    CYAN = FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_BLUE,
    RED = FOREGROUND_INTENSITY | FOREGROUND_RED,
    MAGENTA = FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_BLUE,
    YELLOW = FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN,
    WHITE = FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE,
};


const int ST_N = 7; // Количество всех возможных состояний клетки
const int ST_DRAW_N = 4; // Количество первых перечисленных в списке фактических состояний, которые может использовать кисть (Pen)

// Структура состояния клетки
struct ST {
    idtype code = 0; // Идентификационный код состояния
    std::string name = "EMPTY"; // Название состояния
    Colour colour = WHITE; // Спецификация цвета отображения состояния
};

const ST EMPTY; // Состояние пустой клетки
const ST START =    {   1,  "START",     GREEN};        // Состояние начальной клетка
const ST FINISH =   {   2,  "FINISH",    DARKRED};      // Состояние конечная клетка
const ST OBSTACLE = {   3,  "OBSTACLE",  DARKMAGENTA};  // Состояние клетки, обозначающей препятствие
const ST PATH =     {   4,  "PATH",      BLUE};         // Состояние клетки, обозначающей путь
const ST CUR_SEEN = {   5,  "CUR_SEEN",  YELLOW};       // Состояние рассматриваемой алгоритмом клетки
const ST WAS_SEEN = {   6,  "WAS_SEEN",  GRAY};         // Состояние уже рассмотренной алгоритмом клетки

typedef ST STARR[ST_N]; // Массив состояний
const STARR STATES = { EMPTY, START, FINISH, OBSTACLE, PATH, CUR_SEEN, WAS_SEEN}; // Массив фактических состояний

typedef int CELLNSTELEM; // Элемент массива, в котором будет храниться значение количества клеток сетки с определенным состоянием
typedef CELLNSTELEM CELLNSTARR[ST_N]; // Массив количеств клеток с каждым из фактических состояний

const int BORDER_SIZE = 1;  // Толщина отображаемых границ сетки (доски)
const int MIN_FIELD_H = 3;  // Минимальная высота сетки (доски)
const int MIN_FIELD_W = 3;  // Минимальная ширина сетки (доски)
const int MAX_FIELD_H = 20; // Максмальная высота сетки (доски)
const int MAX_FIELD_W = 20; // Максмальная ширина сетки (доски)

const int START_N = 1;  // Обязательное количество начальных точек на сетке
const int FINISH_N = 1; // Обязательное количество конечных точек на сетке


const int INF = MAX_FIELD_H*MAX_FIELD_W+1; // Алгоритмически недостежимое наибольшое число

const int ALGO_N = 3; // Количество прописанных в программе алгоритмов

// Характеристики алгоритма
struct ALGOPROP {
    idtype code = 0; // Идентификационный код алгоритма
    std::string name = ""; // Название алгоритма
    std::string complexity = ""; // Вычислительная сложность алгоритма
};

const ALGOPROP ALGO_FLOYD = { 0, "Floyd-Warshall algorithm", "O( n^3)"}; // Характеристики для алгоритма Флойда-Уоршелла
const ALGOPROP ALGO_DEIKSTRA   = { 1, "Deikstra algorithm", "O( n^2)"}; // Характеристики для алгоритма Дейкстры
const ALGOPROP ALGO_BELLMAN = { 2, "Bellman-Ford algorithm", "O( n*m)"}; // Характеристики для алгоритма Беллмана Форда

const ALGOPROP ALGO_DEFAULT = ALGO_FLOYD; // Алгоритм по умолчанию

typedef ALGOPROP ALGOPROPARR[ALGO_N]; // Массив характеристик алгоритмов
const ALGOPROPARR ALGOPROPS = { ALGO_FLOYD, ALGO_DEIKSTRA, ALGO_BELLMAN}; // Массив характеристик фактических алгоритмов

// Перечисление флагов запроса : метка, описывающее запрашиваемое действие внутри рабочего пространства (ABoard)
enum QueryFlag {
    F_NULL,     // Флаг бездействия - рабочее пространство (ABoard)
    F_LAUNCH,   // Флаг запуска обработки сетки (Field) выбранным алгоритмом (Algo) внутри доски (Desk) - рабочее пространство (ABoard)
    F_STEP,     // Флаг осществления шага в обработке сетки (Field) выбранным алгоритмом (Algo) внутри доски (Desk) - рабочее пространство (ABoard)
    F_RESET,    // Флаг перезагрузки( возвращения к начальному виду) доски (Desk) - рабочее пространство (ABoard)
    F_RESIZE,   // Флаг для изменения размера доски (Desk) - рабочее пространство (ABoard)
    F_PEN_STATE,    // Флаг изменения состояния, которым кисть (Pen) "закрашивает" клетки доски (Desk) - рабочее пространство (ABoard)
    F_PEN_COORDS,   // Флаг изменения положения кисти (Pen) на доске (Desk) - рабочее пространство (ABoard)
    F_PEN_DRAW,     // Флаг для отрисовки состояния кисти (Pen) в клетке доски (Desk), совпадающей с ее положением - рабочее пространство (ABoard)
    F_DRAW, // Флаг для отрисовки указанного состояния в указанной клетке используя кисть (Pen) - рабочее пространство (ABoard)
    F_ALGO, // Флаг для выбора алгоритма (Algo) обработки сетки (Field) - рабочее пространство (ABoard)
    F_SHOW_DESK,    // Флаг для отображения доски (Desk) - рабочее пространство (ABoard)
    F_SHOW_ALGO,    // Флаг для отображения информации об алгоритме (Algo) - рабочее пространство (ABoard)
    F_SHOW_ALGO_STATE,  // Флаг для отображения этапа выполнения алгоритма (Algo) - рабочее пространство (ABoard)
    F_SHOW_RESULT,   // Флаг для отображения результатов обработки сетки (Field) выбранным алгоритмом (Algo) - рабочее пространство (ABoard)
    F_SLEEP // Флаг для создания задержки между другими запросами в течение определенного времени - рабочее пространство (ABoard)
};

// Запрос к рабочему пространству приложения (ABoard)
struct QUERY {
    QueryFlag flag = F_NULL; // Флаг запроса

    idtype code = 0; // Идентификационный номер сущности, используемой в запросе
    unsigned int val1 = 0; // Дополнительное значение к запросу 1
    unsigned int val2 = 0; // Дополнительное значение к запросу 2
};

// Задержка при отображении сетки в моменты шагов ее обработки или шагов построения пути на ней
const int SHOW_STEP_DELAY = 300;

// Перечислений команд, доступных пользователю
enum APP_MESSAGE {
    A_LAUNCH,   // Запуск визуализации работы алгоритма поиска кратчайшего пути на сетке
    A_NEW,      // Создание новой доски
    A_TEMPLATE, // Создание доски по заготовленному шаблону
    A_PAINT,    // Изменение состояния определенной клетки; "закрашивание" определенной клетки
    A_ALGO,     // Выбор алгоритма поиска кратчайшего пути
    A_ABOUT,    // Информация о программе
    A_EXIT      // Выход из программы
};


// ++ Класс клетки - (Cell)
class Cell {
protected:
    ST state; // Состояние клетки

public:
    Cell(); // Конструктор
    
    errtype set( const Cell&); // Определяет обьект клетки на основе другого обьекта
    errtype setState( ST); // Определяет состояние (state) клетки
    errtype getState( ST&) const; // Возвращает состояние (state) клетки через ссылку
};

Cell::Cell() {
    // Опиcание : Конструктор
    
    state = EMPTY;
}

errtype Cell::set( const Cell& _cell) {
    // Описание : Определяет обьект клетки на основе другого обьекта
    // Аргументы : 
    //      _cell - ссылка на другой обьект клетки
    // Возвращает : Значение корректности выполнения метода

    state = _cell.state;

    return 0; // Возвращает значение о корректном выполнении метода
}

errtype Cell::setState( ST p) {
    // Описание : Определяет состояние клетки (state)
    // Аргументы : 
    //      p - присваиваемое состояние
    // Возвращает : Значение корректности выполнения метода

    if( p.code < 0 && p.code >= ST_N) return 1;
    state = p;

    return 0; // Возвращает значение о корректном выполнении метода
}

errtype Cell::getState( ST& _state) const {
    // Описание : Возвращает состояние клетки (state) через ссылку
    // Аргументы : 
    //      _state - ссылка для возвращаемого состояния клетки (state)
    // Возвращает : Значение корректности выполнения метода
    
    _state = state;

    return 0; // Возвращает значение о корректном выполнении метода
}
// -- Класс клетки - (Cell)


// ++ Класс сетки - (Field)
class Field {
protected:
    int h; // Высота доступной зоны сетки (не считая границ)
    int w; // Ширина доступной зоны сетки (не считая границ)
    Cell** cells; // Двухмерный динамический массив клеток

public:
    Field(); // Конструктор
    ~Field(); // Деструктор

    errtype set( const Field&); // Определение обьекта сетки на основе другого обьекта 
    errtype resize( int, int);  // Изменение размера доступной зоны сетки на (_h, _w) 
    errtype setCellState( int, int, ST);    // Определить состояние (state) выбранной клетки с координатами (x, y) внутри доступной зоны сетки 
    errtype erase( int, int);   // Определить состояние определенной клетки (state) с координатами (x, y) внутри доступной зоны сетки как (EMPTY) 
    errtype clear();    // Определить все клетки внутри доступной зоны сетки как (EMPTY)
    errtype pass(); // Определить все клетки с состоянием (CUR_SEEN) как (WAS_SEEN)
    errtype reset(); // Привести доступную зону сетки к изначальному( необработанному) виду

    errtype getHeight( int&) const; // Получить высоту сетки 
    errtype getWidth( int&) const;  // Получить ширину сетки
    errtype getCellState( int, int, ST&) const; // Получить состояние выбранной клетки с координатами (x, y) внутри доступной зоны сетки
    errtype getAnyCellState( int, int, ST&) const; // Получить состояние любой клетки сетки

private:
    errtype setBorders(); // Строит границы доступной зоны сетки
};


Field::Field() {
    // Описание : Конструктор

    h = MIN_FIELD_H; // Изначальное значение высоты сетки
    w = MIN_FIELD_W; // Изначальное значение ширины сетки

    // Инициализация сетки
    cells = new Cell* [2*BORDER_SIZE+h];
    for( int i = 0; i < 2*BORDER_SIZE+h; i++)
        cells[i] = new Cell [2*BORDER_SIZE+w];
    setBorders();
}

Field::~Field() {
    // Описание : Деструктор

    if( cells != nullptr) {
        for( int i = 0; i < 2*BORDER_SIZE+h; i++)
            delete [] cells[i];
        delete [] cells;
    }
}

errtype Field::set( const Field& _field) {
    // Описание : Определение обьекта сетки на основе другого обьекта 
    // Аргументы : 
    //      _field - ссылка на др обьект сетки
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    // Изменение размера нынешней сетки к размеру другой сетки
    fault = resize( _field.w, _field.h);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

    // Присваивание всех клеток другой сетки к нынешней сетке
    ST state;
    for( int i = 0; i < 2*BORDER_SIZE+h; i++) {
        for( int j = 0; j < 2*BORDER_SIZE+w; j++) {
            // Получение состояния клетки другой сетки под индесками (i, j)
            fault = _field.cells[i][j].getState( state);
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
            // Определение состояния клетки нынешней сетки к состоянию соответствующей клетки другой сетки
            fault = cells[i][j].setState( state);
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
        }
    }

    return fault; // Возвращает значение корректности выполнения метода
}

errtype Field::resize( int _w, int _h) {
    // Описание : Изменение размера доступной зоны сетки на (_h, _w)
    // Аргументы : 
    //      _w - новое значение ширины доступной зоны сетки
    //      _h - новое значение высоты доступной зоны сетки
    // Возвращает : Значение корректности выполнения метода

    // Если новое значение высоты соответствует диапазону разрешенных значений
    if( _h >= MIN_FIELD_H && _h <= MAX_FIELD_H) {
        // Если новое значение высоты соответствует диапазону разрешенных значений
        if( _w >= MIN_FIELD_W && _w <= MAX_FIELD_W) {
            // Удаление старой сетки
            if( cells != nullptr) {
                for( int i = 0; i < 2*BORDER_SIZE+h; i++)
                    delete [] cells[i];
                delete [] cells;
            }

            // Создание новой сетки
            h = _h;
            w = _w;
            cells = new Cell* [2*BORDER_SIZE+h];
            for( int i = 0; i < 2*BORDER_SIZE+h; i++)
                cells[i] = new Cell [2*BORDER_SIZE+w];
            setBorders();

            return 0; // Возвращает значение о корректном выполнении метода
        }
        
        return 1; // Возвращает Err: попытка присвоения некорректного значения ширины (_w)
    }
    
    return 1; // Возвращает Err: попытка присвоения некорректного значения высоты (_h)
}

errtype Field::setCellState( int x, int y, ST _state) {
    // Описание : Определить состояние (state) выбранной клетки с координатами (x, y) внутри доступной зоны сетки
    // Аргументы : 
    //      x - абцисса в доступной зоне сетки
    //      y - ордината в доступной зоне сетки
    //      _state - присваиваемое состояние
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    if( cells == nullptr)   return 1; // Если динамический массив клеток пустой, возвращает Err
    if( y < 0 && y >= h)    return 1; // Если клетка с данной ординатой не лежит внутри доступной зоны сетки, возвращает Err 
    if( x < 0 && x >= w)    return 1; // Если клетка с данной абциссой не лежит внутри доступной зоны сетки, возвращает Err

    fault = cells[BORDER_SIZE+y][BORDER_SIZE+x].setState( _state); // Присвоение указанного состояния выбранной клетке сетки
    
    return fault; // Возвращает значение корректности выполнения метода
}

errtype Field::erase( int x, int y) {
    // Описание : Определить состояние определенной клетки (state) с координатами (x, y) внутри доступной зоны как (EMPTY)
    // Аргументы : 
    //      x - абцисса в доступной зоне сетки
    //      y - ордината в доступной зоне сетки
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    if( cells == nullptr)   return 1; // Если динамический массив клеток пустой, возвращает Err
    if( y < 0 && y >= h)    return 1; // Если клетка с данной ординатой не лежит внутри доступной зоны сетки, возвращает Err 
    if( x < 0 && x >= w)    return 1; // Если клетка с данной абциссой не лежит внутри доступной зоны сетки, возвращает Err
    
    // Присвоение указанного состояния выбранной клетке сетки
    fault = cells[BORDER_SIZE+y][BORDER_SIZE+x].setState( EMPTY);
    
    return fault; // Возвращает значение корректности выполнения метода
}

errtype Field::clear() {
    // Описание : Определить все клетки внутри доступной зоны сетки как (EMPTY)     
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    for( int i = 0; i < h; i++) {
        for( int j = 0; j < w; j++) {
            fault = erase( i, j);
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
        }
    }

    // Возвращает значение корректности выполнения метода
    return fault; // Возвращает значение корректности выполнения метода
}

errtype Field::pass() {
    // Описание : Определить все клетки с состоянием (CUR_SEEN) как (WAS_SEEN)
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    for( int x = 0; x < w; x++) {
        for( int y = 0; y < h; y++) {
            ST state;
            fault = getCellState( x, y, state);
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

            if( state.code == CUR_SEEN.code) {
                fault = setCellState( x, y, WAS_SEEN);
                if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
            }
        }
    }

    return fault; // Возвращает значение корректности выполнения метода
}

errtype Field::reset() {
    // Описание : Привести доступную зону сетки к изначальному( необработанному) виду
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    for( int i = 0; i < h; i++) {
        for( int j = 0; j < w; j++) {
            ST state;
            fault = cells[BORDER_SIZE+i][BORDER_SIZE+j].getState( state);
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

            if( state.code != EMPTY.code && 
                state.code != START.code &&
                state.code != FINISH.code &&
                state.code != OBSTACLE.code ) {
                fault = cells[BORDER_SIZE+i][BORDER_SIZE+j].setState( EMPTY);
                if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
            }
        }
    }

    return fault; // Возвращает значение корректности выполнения метода
}

errtype Field::getHeight( int& _h) const {
    // Описание : Возвращает высоту доступной зоны сетки (h) через ссылку
    // Аргументы : 
    //      _h - ссылка для возвращаемого значения высоты доступной зоны сетки (h)
    // Возвращает : Значение корректности выполнения метода

    _h = h;

    return 0; // Возвращает значение о корректном выполнении метода
}

errtype Field::getWidth( int& _w) const {
    // Описание : Возвращает ширину доступной зоны сетки (w) через ссылку
    // Аргументы : 
    //      _w - ссылка для возвращаемого значения ширины доступной зоны сетки (w)
    // Возвращает : Значение корректности выполнения метода

    _w = w;

    return 0; // Возвращает значение о корректном выполнении метода
}

errtype Field::getCellState( int x, int y, ST& _state) const {
    // Описание : Возвращает состояние клетки в доступной зоне сетки через ссылку
    // Аргументы : 
    //      x - абцисса в доступной зоне сетки
    //      y - ордината в доступной зоне сетки    
    //      _state - ссылка для возвращаемого значения состояния указанной клетки в доступной зоне сетки  
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    if( cells == nullptr)   return 1; // Если динамический массив клеток пустой, возвращает Err
    if( y < 0 && y >= h)    return 1; // Если клетка с данной ординатой не лежит внутри доступной зоны сетки, возвращает Err 
    if( x < 0 && x >= w)    return 1; // Если клетка с данной абциссой не лежит внутри доступной зоны сетки, возвращает Err

    // Получение состояния указанной клетки 
    fault = cells[BORDER_SIZE+y][BORDER_SIZE+x].getState( _state);

    return fault; // Возвращает значение корректности выполнения метода
}

errtype Field::getAnyCellState( int x, int y, ST& _state) const {
    // Описание : Возвращает состояние любой клетки сетки через ссылку
    // Аргументы : 
    //      x - абцисса в доступной зоне сетки
    //      y - ордината в доступной зоне сетки    
    //      _state - ссылка для возвращаемого значения состояния указанной клетки со всей сетки  
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    if( cells == nullptr)   return 1; // Если динамический массив клеток пустой, возвращает Err
    if( y < 0 && y >= h)    return 1; // Если клетка с данной ординатой не лежит внутри доступной зоны сетки, возвращает Err 
    if( x < 0 && x >= w)    return 1; // Если клетка с данной абциссой не лежит внутри доступной зоны сетки, возвращает Err

    // Возвращает значение корректности выполнения метода
    fault = cells[y][x].getState( _state);
    return fault; // Возвращает значение корректности выполнения метода
}

errtype Field::setBorders() {
    // Описание : Устанавливает границы сетки
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    // Строит границы доступной зоны внутри сетки справа и слева
    for( int i = 0; i < 2*BORDER_SIZE+h; i++) {
        for( int j = 0; j < BORDER_SIZE; j++) {
            fault = cells[i][j].setState( OBSTACLE);
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
            cells[i][2*BORDER_SIZE+w-1-j].setState( OBSTACLE);
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
        }
    }

    // Строит границы доступной зоны внутри сетки сверху и снизу
    for( int j = 0; j < 2*BORDER_SIZE+w; j++) {
        for( int i = 0; i < BORDER_SIZE; i++) {
            fault = cells[i][j].setState( OBSTACLE);
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
            fault = cells[2*BORDER_SIZE+h-1-i][j].setState( OBSTACLE);
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
        }
    }

    return fault; // Возвращает значение корректности выполнения метода
}
// -- Класс сетки - (Field)


// ++ Абстрактный базовый класс для всех алгоритмов - (Algo)
class Algo {
protected:
    // Общие величины для алгоритмов
    ALGOPROP prop; // Характеристики алгоритма
    Field field; // Обрабатываемая сетка
    int nIter; // Количество выполненых итераций алгоритма
    int pathLength; // Длина построенного алгоритмом пути

    int n; // Количество вершин графа, построенного по сетке
    int startVert; // Начальная вершина графа
    int finishVert; // Конечная вершина графа

    int nStepProcess; // Счетчик шагов обработки алгоритмов
    int buildPathVert; // Вершина, от которой строится путь

public:
    Algo(); // Конструктор

    errtype getCode( idtype&) const; // Возвращает идентификационный код алгоритма через ссылку
    errtype getName( std::string&) const; // Возвращает имя алгоритма через ссылку
    errtype getComplexity( std::string&) const; // Возвращает сложность алгоритма через ссылку
    errtype getField( Field&) const;    // Возвращает копию обрабатываемой внутри обьекта сетки через ссылку
    errtype getNIter( int&) const;      // Возвращает количество выполненных итераций поиска конечной точки через ссылку
    errtype getPathLength( int&) const; // Возвращает длину построенного алгоритмом пути через ссылку

    virtual errtype init( Field&);      // Строит сетку по шаблону другой сетки, переданной по ссылке
    virtual errtype stepProcess();      // Осуществляет шаг в выполении алгоритма
    virtual bool isFinishedProcess();   // Возвращает логическое значение к условию - закончен ли процесс обработки сетки алгоритмом
    virtual errtype stepBuildPath();    // Осуществляет шаг в построении пути в сетке
    virtual bool isFinishedBuildPath(); // Возвращает логическое значение к условию - закончен ли процесс построения пути в сетке
    virtual errtype reset();            // Приведение сетки к изначальному( необработанному) виду

protected:
    virtual errtype build(); // Подготовка всех атрибутов алгоритма к последующей обработке и построению пути
    errtype getGraphX( int&, int); // Преобразование индекса вершины в матрице смежности (adj) в абциссу клетки (x) на сетке, возвращаемую через ссылку
    errtype getGraphY( int&, int); // Преобразование индекса вершины в матрице смежности (adj) в ординату клетки (y) на сетке, возвращаемую через ссылку
};

Algo::Algo() {
    // Описание : Конструктор

    nIter = 0; // Изначальное количество произведенных итераций поиска конечной точки
    pathLength = INF; // Изначальное значение длины пути

    n = 0;
    startVert = -1;
    finishVert = -1;
}

errtype Algo::getCode( idtype& _code) const {
    // Описание : Возвращает идентификационный код алгоритма через ссылку
    // Аргументы : 
    //      _code - ссылка для возвращаемого идентификационного код алгоритма
    // Возвращает : Значение корректности выполнения метода

    _code = prop.code;
    
    return 0; // Возвращает значение о корректном выполнении метода
} // Get code of algorithm

errtype Algo::getName( std::string& _name) const  {
    // Описание : Возвращает имя алгоритма через ссылку
    // Аргументы : 
    //      _name - ссылка для возвращаемого имени алгоритма
    // Возвращает : Значение корректности выполнения метода
    
    _name = prop.name;    
    
    return 0; // Возвращает значение о корректном выполнении метода
} // Get name of algorithm

errtype Algo::getComplexity( std::string& _complexity) const {
    // Описание : Возвращает вычислительную сложность алгоритма через ссылку
    // Аргументы : 
    //      _complexity - ссылка для возвращаемой вычислительной сложности алгоритма
    // Возвращает : Значение корректности выполнения метода

    _complexity = prop.complexity;

    return 0; // Возвращает значение о корректном выполнении метода
}

errtype Algo::getField( Field& _field) const {
    // Описание : Возвращает копию обрабатываемой внутри обьекта сетки через ссылку
    // Аргументы : 
    //      _field - ссылка для возвращаемой копии обрабатываемой внутри обьекта сетки
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполненния метода
    fault = _field.set( field);
    
    return fault; // Возвращает значение о корректном выполнении метода
} // Get pointer to Field (Field*)

errtype Algo::getNIter( int& _nIter) const {
    // Описание : Возвращает количество выполненных итераций алгоритма
    // Аргументы : 
    //      _nIter - ссылка для возвращаемого значения количества выполненных итераций поиска конечной точки
    // Возвращает : Значение корректности выполнения метода

    _nIter = nIter;
    
    return 0; // Возвращает значение о корректном выполнении метода
}

errtype Algo::getPathLength( int& _len) const { 
    // Описание : Возвращает длину построенного алгоритмом пути через ссылку
    // Аргументы : 
    //      _len - ссылка для возвращаемого значения длины построенного алгоритмом пути
    // Возвращает : Значение корректности выполнения метода

    _len = pathLength;    
    
    return 0; // Возвращает значение о корректном выполнении метода
}

errtype Algo::init( Field& _field) {
    // Описание : Строит сетку по шаблону другой сетки, переданной по ссылке
    // Аргументы : 
    //      _field - ссылка на сетку, по шаблону которой будет построена сетка для обработки алгоритмом
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    fault = field.set( _field);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

    fault = build();
    return fault; // Возвращает значение корректности выполнения метода
}

errtype Algo::stepProcess() { 
    // Описание : Осуществляет шаг в выполении обработки сетки алгоритмом
    // Возвращает : Значение корректности выполнения метода

    return 0; // Возвращает значение о корректном выполнении метода
} // Move to next step of algorithm

bool Algo::isFinishedProcess() {
    // Описание : Возвращает логическое значение к условию - закончен ли процесс обработки сетки алгоритмом
    // Возвращает : Логическое значение выполнения или невыполнения описанного условия

    return (nStepProcess >= n);
} // Condition : if algorithm is finished 

errtype Algo::stepBuildPath() {
    // Описание : Осуществляет шаг в построении пути в сетке
    // Возвращает : Значение корректности выполнения метода

    return 0; // Возвращает значение о корректном выполнении метода
} // Move to next step of path building

bool Algo::isFinishedBuildPath() {
    // Описание : Возвращает логическое значение к условию - закончен ли процесс построения пути в сетке
    // Возвращает : Логическое значение выполнения или невыполнения описанного условия

    return (buildPathVert == startVert || pathLength == INF);
} // Condition : if path building is finished

errtype Algo::reset() {
    // Описание : Приведение сетки к изначальному( необработанному) виду
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    fault = field.reset();
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

    fault = build();
    return fault; // Возвращает значение корректности выполнения метода
}

errtype Algo::build() {
    // Описание : Подготовка всех атрибутов алгоритма к последующей обработке и построению пути
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    nIter = 0;
    pathLength = INF;

    nStepProcess = 0;
    buildPathVert = finishVert;

    // Получение изначальных размеров из нынешней сетки
    int h;
    fault = field.getHeight( h);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
    int w;
    fault = field.getWidth( w);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

    n = h*w;
    // Индексы начальной и конечной вершин (клеток)
    for( int i = 0; i < n; i++) {
        ST tmpState;
        field.getCellState( i%w, i/w, tmpState);
        if( tmpState.code == START.code) startVert = i;
        if( tmpState.code == FINISH.code) finishVert = i;
    }
    
    return fault; // Возвращает значение о корректном выполнении метода
}

errtype Algo::getGraphX( int& x, int i) {
    // Описание : 
    //      Преобразование индекса вершины в матрице смежности (adj) в абциссу клетки (x) на сетке,
    //      возвращаемую через ссылку
    // Аргументы : 
    //      x - ссылка для возвращаемого значения абциссы клетки на сетке
    //      i - индекс вершины в графе
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода
    
    if( i < 0 || i >= n) return 1; // Если данной вершины нет в графе, возвращает ERR

    int w;
    fault = field.getWidth(w);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
    
    x = i%w;
    return fault; // Возвращает значение корректности выполнения метода
}

errtype Algo::getGraphY( int& y, int i) {
    // Описание : 
    //      Преобразование индекса вершины в матрице смежности (adj) в ординату клетки (y) на сетке, 
    //      возвращаемую через ссылку
    // Аргументы : 
    //      y - ссылка для возвращаемого значения ординаты клетки на сетке
    //      i - индекс вершины в графе
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    if( i < 0 || i >= n) return 1; // Если данной вершины нет в графе, возвращает ERR

    int w;
    fault = field.getWidth(w);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

    y = i/w;
    return fault; // Возвращает значение корректности выполнения метода
}
// -- class Algo


// ++ Класс алгоритма Флойда-Уоршелла - (AlgoFloyd)
class AlgoFloyd : public Algo {
    // Спецификации для данного алгоритма
    int** adj; // Матрица смежности графа

    int** dist; // Динамический массив минимальных длин пути от начальной вершины до всех остальных вершин графа
    int** parents; // Динамический массив вершин, из которых можно попасть в вершину по индексу за результирующе кратчайшее расстояние

public:
    AlgoFloyd(); // Конструктор
    ~AlgoFloyd(); // Деструктор

    errtype init( Field&);      // Строит сетку по шаблону другой сетки, переданной по ссылке
    errtype stepProcess();      // Осуществляет шаг в выполении алгоритма
    errtype stepBuildPath();    // Осуществляет шаг в построении пути в сетке
    errtype reset();            // Приведение сетки к изначальному( необработанному) виду

private:
    errtype build(); // Подготовка всех атрибутов алгоритма к последующей обработке и построению пути
};

AlgoFloyd::AlgoFloyd() {
    // Описание : Конструктор

    prop = ALGO_FLOYD;
    nIter = 0;
    pathLength = INF;

    n = 0;
    startVert = -1;
    finishVert = -1;

    adj = nullptr;
    dist = nullptr;
    parents = nullptr;

    nStepProcess = 0;
    buildPathVert = -1;
}

AlgoFloyd::~AlgoFloyd() {
    // Описание : Деструктор

    if( adj != nullptr) {
        for( int i = 0; i < n; i++)
            delete [] adj[i];
        delete [] adj;
    }

    if( dist != nullptr) {
        for( int i = 0; i < n; i++)
            delete [] dist[i];
        delete [] dist;
    }

    if( parents != nullptr) {
        for( int i = 0; i < n; i++)
            delete [] parents[i];
        delete [] parents;
    }
}

errtype AlgoFloyd::init( Field& _field) {
    // Описание : Строит сетку по шаблону другой сетки, переданной по ссылке
    // Аргументы : 
    //      _field - ссылка на сетку, по шаблону которой будет построена сетка для обработки алгоритмом
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    fault = field.set( _field);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

    fault = build();
    return fault; // Возвращает значение корректности выполнения метода
}

errtype AlgoFloyd::stepProcess() {
    // Описание : Осуществляет шаг
    //  в выполении обработки сетки алгоритмом
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    // Если процесс обработки сетки алгоритмом завершен, возвращает Err
    if( isFinishedProcess())
        return 1;

    // Не относящееся к алгоритму : переводит все клетки из (CUR_SEEN) в (WAS_SEEN)
    field.pass();
    
    // ++ Алгоритм

    int x; // Абцисса рассматриваемой клетки
    int y; // Ордината рассматриваемой клетки

    // Рассматриваются минимальные пути
    for( int i = 0; i < n; i++) {
        for( int j = 0; j < n; j++) {
            // Если был найден короче путь от начальной вершины до вершины под индексом (j) 
            if( dist[i][nStepProcess]+dist[nStepProcess][j] < dist[i][j]) {
                dist[i][j] = dist[i][nStepProcess]+dist[nStepProcess][j]; // Сохраняется найденный более короткий путь
                parents[i][j] = parents[nStepProcess][j];

                if( j != startVert && j != finishVert) {
                    // Не относящееся к алгоритму : определяет рассматриваемую алгоритмом клетку как "CUR_SEEN" 
                    fault = getGraphX( x, j);
                    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
                    fault = getGraphY( y, j);
                    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
                    field.setCellState( x, y, CUR_SEEN);
                }
            }

            // Увеличивает на 1 количество выполненных итераций
            nIter++;
        }
    }

    // Сохраняет последнее найденное значение длины пути от начальной до конечной вершины
    pathLength = min( dist[startVert][finishVert], dist[finishVert][startVert]);
    // Увеличивает на 1 количество выполненных шагов алгоритма
    nStepProcess++;
    // -- Алгоритм

    return fault; // Возвращает значение корректности выполнения метода
}

errtype AlgoFloyd::stepBuildPath() {
    // Описание : Осуществляет шаг в построении пути в сетке
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода
    
    // Если процесс построения пути на сетке завершен, то возвращает Err
    if( isFinishedBuildPath()) return 1;

    // ++ Процесс построения пути
    buildPathVert = parents[startVert][buildPathVert];
    int x; 
    fault = getGraphX( x, buildPathVert); 
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
    int y; 
    fault = getGraphY( y, buildPathVert); 
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

    if( buildPathVert != startVert)
        fault = field.setCellState( x, y, PATH);
    // -- Процесс построения пути

    return fault; // Возвращает значение корректности выполнения метода
}

errtype AlgoFloyd::reset() {
    // Описание : Приведение сетки к изначальному( необработанному) виду
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    fault = field.reset();
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

    fault = build();
    return fault; // Возвращает значение корректности выполнения метода
}

errtype AlgoFloyd::build() {
    // Описание : Подготовка всех атрибутов алгоритма к последующей обработке и построению пути
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    // Удаление предыдущей матрицы смежности графа
    if( adj != nullptr) {
        for( int i = 0; i < n; i++)
            delete [] adj[i];
        delete [] adj;
    }

    // Удаление предыдущих данных алгоритма
    if( dist != nullptr) {
        for( int i = 0; i < n; i++)
            delete [] dist[i];
        delete [] dist;
    }
    if( parents != nullptr) {
        for( int i = 0; i < n; i++)
            delete [] parents[i];
        delete [] parents;
    }

    // Обязательное использование версии базового класса данного метода после удаления всех страых данных
    fault = Algo::build();
    if( fault) return fault;

    // Создание новой матрицы смежности
    int xi, yi, xj, yj;
    ST tmpState;

    adj = new int* [n];
    for( int i = 0; i < n; i++) {
        adj[i] = new int [n];
        for( int j = 0; j < n; j++) {
            adj[i][j] = 0;

             
            fault = getGraphX( xi, i);  
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
            fault = getGraphY( yi, i);  
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
            fault = getGraphX( xj, j);  
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
            fault = getGraphY( yj, j);  
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

            field.getCellState( xj, yj, tmpState);

            // Если не рассматривается одна и та же клетка, и данная клетка не является (OBSTACLE)
            if( i != j && tmpState.code != OBSTACLE.code) {
                // Если достижима справа
                if( (yi == yj) && (xi+1 == xj) ) adj[i][j] = 1;
                // Если достижима слева
                else if( (yi == yj) && (xi-1 == xj) ) adj[i][j] = 1;
                // Если достижима сверху
                else if( (yi+1 == yj) && (xi == xj) ) adj[i][j] = 1;
                // Если достижима снизу
                else if( (yi-1 == yj) && (xi == xj) ) adj[i][j] = 1;
            }
        }
    }

    // Новые данные алгоритма
    dist = new int* [n];
    for( int i = 0; i < n; i++) {
        dist[i] = new int [n];
        for( int j = 0; j < n; j++) {
            dist[i][j] = INF;
            if( i == j) dist[i][j] = 0;
            else if( adj[i][j]) dist[i][j] = adj[i][j];
        }
    }

    // Массив предшествующих вершин для построения минимального пути до них
    parents = new int* [n];
    for( int i = 0; i < n; i++) {
        parents[i] = new int [n];
        for( int j = 0; j < n; j++) {
            parents[i][j] = -1;
            if( i == j || adj[i][j]) parents[i][j] = i;
        }
    }

    return fault; // Возвращает значение корректности выполнения метода
}
// -- Класс алгоритма Флойда-Уоршелла - (AlgoFloyd)


// ++ Класс алгоритма  - (AlgoDeikstra)
class AlgoDeikstra : public Algo {
    // Спецификации для данного алгоритма
    int** adj; // Матрица смежности графа

    int* dist; // Динамический массив минимальных длин пути от начальной вершины до всех остальных вершин графа
    int* visited; // Динамический массив меток посещения вершин графа
    int* parents; // Динамический массив вершин, из которых можно попасть в вершину по индексу за результирующе кратчайшее расстояние

public:
    AlgoDeikstra(); // Конструктор
    ~AlgoDeikstra(); // Деструктор

    errtype init( Field&);      // Строит сетку по шаблону другой сетки, переданной по ссылке
    errtype stepProcess();      // Осуществляет шаг в выполении алгоритма
    errtype stepBuildPath();    // Осуществляет шаг в построении пути в сетке
    errtype reset();            // Приведение сетки к изначальному( необработанному) виду

private:
    errtype build(); // Подготовка всех атрибутов алгоритма к последующей обработке и построению пути
};

AlgoDeikstra::AlgoDeikstra() {
    // Описание : Конструктор

    prop = ALGO_DEIKSTRA;
    nIter = 0;
    pathLength = 0;

    n = 0;
    startVert = -1;
    finishVert = -1;

    adj = nullptr;
    dist = nullptr;
    visited = nullptr;
    parents = nullptr;

    nStepProcess = 0;
    buildPathVert = -1;
}

AlgoDeikstra::~AlgoDeikstra() {
    // Описание : Деструктор

    if( adj != nullptr) {
        for( int i = 0; i < n; i++)
            delete [] adj[i];
        delete [] adj;
    }

    if( dist != nullptr) delete [] dist;
    if( visited != nullptr) delete [] visited;
    if( parents != nullptr) delete [] parents;
}

errtype AlgoDeikstra::init( Field& _field) {
    // Описание : Строит сетку по шаблону другой сетки, переданной по ссылке
    // Аргументы : 
    //      _field - ссылка на сетку, по шаблону которой будет построена сетка для обработки алгоритмом
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    fault = field.set( _field);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

    fault = build();
    return fault; // Возвращает значение корректности выполнения метода
}

errtype AlgoDeikstra::stepProcess() {
    // Описание : Осуществляет шаг
    //  в выполении обработки сетки алгоритмом
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    // Если процесс обработки сетки алгоритмом завершен, возвращает Err
    if( isFinishedProcess()) return 1;

    // Не относящееся к алгоритму : переводит все клетки из (CUR_SEEN) в (WAS_SEEN)
    field.pass();

    // ++ Алгоритм
    // Находит непосещенную ранее алгоритмом клетку
    int curVert = -1;
    for( int i = 0; i < n; i++) {
        if( !visited[i]) {
            if( curVert == -1)
                curVert = i;
            else if( dist[i] < dist[curVert])
                curVert = i;
        }
    }
    // В случае, если все вершины уже были посещены, однако путь от начальной
    // до конечной вершины еще не был найден, то выполнение алгоритма прекращается
    if( curVert == -1) {
        nStepProcess = n;
        return 0; // Возвращает значение о корректном выполнении метода
    }
    // В случае, если не может быть найден путь до конечной вершины
    if( dist[curVert] == INF) {
        nStepProcess = n;
        return 0; // Возвращает значение о корректном выполнении метода
    }

    // Рассматриваемая в данный момент вершину отмечаем как "посещенную"
    visited[curVert] = 1;
    // Рассматриваются минимальные пути от начальной вершины до каждой из вершин через рассматриваемую в даннный момент вершину
    for( int i = 0; i < n; i++) {
        // Если был найден короче путь от начальной вершины до вершины под индексом (i)
        if( dist[curVert]+adj[curVert][i] < dist[i]) {
            dist[i] = dist[curVert]+adj[curVert][i]; // Сохраняется найденный более короткий путь
            parents[i] = curVert; // Меняется вершина, из которой можно попасть в вершину под индексом (i) за результирующе минимальный путь из начальной вершины до нее

            // Если была найдена конечная вершина
            if( i == finishVert) {
                nStepProcess = n;
                pathLength = dist[finishVert];

                // Не относящееся к алгоритму : переводит все клетки из (CUR_SEEN) в (WAS_SEEN)
                field.pass();

                break;
            }

            // Не относящееся к алгоритму : определяет рассматриваемую алгоритмом клетку как "CUR_SEEN"
            int x; fault = getGraphX(x, i);
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
            int y; fault = getGraphY(y, i);
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
            field.setCellState( x, y, CUR_SEEN);
        }

        // Увеличивает на 1 количество выполненных итераций
        nIter++;
    }

    // Увеличивает на 1 количество выполненных шагов алгоритма
    nStepProcess++;
    // -- Алгоритм

    return fault; // Возвращает значение корректности выполнения метода
}

errtype AlgoDeikstra::stepBuildPath() {
    // Описание : Осуществляет шаг в построении пути в сетке
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    // Если процесс построения пути на сетке завершен, то возвращает Err
    if( isFinishedBuildPath()) return 1;

    // ++ Процесс построения пути
    buildPathVert = parents[buildPathVert];
    int x;
    fault = getGraphX( x, buildPathVert);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
    int y;
    fault = getGraphY( y, buildPathVert);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

    if( buildPathVert != startVert)
        fault = field.setCellState( x, y, PATH);
    // -- Процесс построения пути

    return fault; // Возвращает значение корректности выполнения метода
}

errtype AlgoDeikstra::reset() {
    // Описание : Приведение сетки к изначальному( необработанному) виду
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    fault = field.reset();
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

    fault = build();
    return fault; // Возвращает значение корректности выполнения метода
}

errtype AlgoDeikstra::build() {
    // Описание : Подготовка всех атрибутов алгоритма к последующей обработке и построению пути
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    // Удаление предыдущей матрицы смежности графа
    if( adj != nullptr) {
        for( int i = 0; i < n; i++)
            delete [] adj[i];
        delete [] adj;
    }

    // Удаление предыдущих данных алгоритма
    if( dist != nullptr) delete [] dist;
    if( visited != nullptr) delete [] visited;
    if( parents != nullptr) delete [] parents;

    // Обязательное использование версии базового класса данного метода после удаления всех страых данных
    fault = Algo::build();
    if( fault) return fault;

    // Создание новой матрицы смежности
    int xi, yi, xj, yj;
    ST tmpState;

    adj = new int* [n];
    for( int i = 0; i < n; i++) {
        adj[i] = new int [n];
        for( int j = 0; j < n; j++) {
            // По умолчанию все вершины недостижимы (не учитывая начальной клетки)
            adj[i][j] = INF;

            fault = getGraphX( xi, i);
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
            fault = getGraphY( yi, i);
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
            fault = getGraphX( xj, j);
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
            fault = getGraphY( yj, j);
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

            field.getCellState( xj, yj, tmpState);

            // Если не рассматривается одна и та же клетка, и данная клетка не является (OBSTACLE)
            if( i != j && tmpState.code != OBSTACLE.code) {
                // Если достижима справа
                if( (yi == yj) && (xi+1 == xj) ) adj[i][j] = 1;
                // Если достижима слева
                else if( (yi == yj) && (xi-1 == xj) ) adj[i][j] = 1;
                // Если достижима сверху
                else if( (yi+1 == yj) && (xi == xj) ) adj[i][j] = 1;
                // Если достижима снизу
                else if( (yi-1 == yj) && (xi == xj) ) adj[i][j] = 1;
            }
        }
    }

    // Новые данные алгоримта
    dist = new int [n];
    visited = new int [n];
    parents = new int [n];
    for( int i = 0; i < n; i++) {
        // Мин расстояния до вершин от начальной вершины
        dist[i] = INF;
        if( i == startVert) dist[i] = 0; // До начальной вершины равно 0
        // Метка посещяемости вершин
        visited[i] = 0;
        // Массив предшествующих вершин для построения минимального пути до них
        parents[i] = -1;
    }

    return fault; // Возвращает значение корректности выполнения метода
}
// -- Класс алгоритма  - (AlgoDeikstra)


// ++ Класс алгоритма Беллмона-Форда - (AlgoBellman)
class AlgoBellman : public Algo {
    // Спецификации для данного алгоритма
    std::vector <std::tuple<int, int, int>> edges;

    int* dist; // Динамический массив минимальных длин пути от вершины до вершины графа
    int* parents; // Динамический массив вершин, из которых можно попасть в вершину по индексу за результирующе кратчайшее расстояние

public:
    AlgoBellman(); // Конструктор
    ~AlgoBellman(); // Деструктор

    errtype init( Field&);      // Строит сетку по шаблону другой сетки, переданной по ссылке
    errtype stepProcess();      // Осуществляет шаг в выполении алгоритма
    errtype stepBuildPath();    // Осуществляет шаг в построении пути в сетке
    errtype reset();            // Приведение сетки к изначальному( необработанному) виду

private:
    errtype build(); // Подготовка всех атрибутов алгоритма к последующей обработке и построению пути
};

AlgoBellman::AlgoBellman() {
    // Описание : Конструктор

    prop = ALGO_BELLMAN;
    nIter = 0;
    pathLength = INF;

    n = 0;
    startVert = -1;
    finishVert = -1;

    dist = nullptr;
    parents = nullptr;

    nStepProcess = 0;
    buildPathVert = -1;
}

AlgoBellman::~AlgoBellman() {
    // Описание : Деструктор

    if( dist != nullptr) delete [] dist;
    if( parents != nullptr) delete [] parents;
}

errtype AlgoBellman::init( Field& _field) {
    // Описание : Строит сетку по шаблону другой сетки, переданной по ссылке
    // Аргументы : 
    //      _field - ссылка на сетку, по шаблону которой будет построена сетка для обработки алгоритмом
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    fault = field.set( _field);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

    fault = build();
    return fault; // Возвращает значение корректности выполнения метода
}

errtype AlgoBellman::stepProcess() {
    // Описание : Осуществляет шаг в выполении обработки сетки алгоритмом
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    // Не относящееся к алгоритму : переводит все клетки из (CUR_SEEN) в (WAS_SEEN)
    field.pass();
    // Если процесс обработки сетки алгоритмом завершен, возвращает Err
    if( isFinishedProcess()) return 1;
    
    // ++ Алгоритм
    for( auto edge : edges) {
        int a, b, w;
        std::tie( a, b, w) = edge;

        if( dist[a] + w < dist[b]) {
            dist[b] = dist[a] + w;
            parents[b] = a;

            // Если была найдена конечная вершина
            if( b == finishVert) {
                nStepProcess = n-1;
                pathLength = dist[finishVert];

                // Не относящееся к алгоритму : переводит все клетки из (CUR_SEEN) в (WAS_SEEN)
                field.pass();

                break;
            }

            // Не относящееся к алгоритму : определяет рассматриваемую алгоритмом клетку как "CUR_SEEN" 
            int x; fault = getGraphX( x, b);
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
            int y; fault = getGraphY( y, b);
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
            field.setCellState( x, y, CUR_SEEN);

            // Увеличивает количество итераций на 1
            nIter++;
        }
    }

    // Увеличивает на 1 количество выполненных шагов алгоритма
    nStepProcess++;
    // -- Алгоритм

    return fault; // Возвращает значение корректности выполнения метода
}

errtype AlgoBellman::stepBuildPath() {
    // Описание : Осуществляет шаг в построении пути в сетке
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    // Если процесс построения пути на сетке завершен, то возвращает Err
    if( isFinishedBuildPath()) return 1;

    // ++ Процесс построения пути
    buildPathVert = parents[buildPathVert];
    int x; 
    fault = getGraphX( x, buildPathVert); 
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
    int y; 
    fault = getGraphY( y, buildPathVert); 
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

    if( buildPathVert != startVert)
        fault = field.setCellState( x, y, PATH);
    // -- Процесс построения пути

    return fault; // Возвращает значение корректности выполнения метода
}

errtype AlgoBellman::reset() {
    // Описание : Приведение сетки к изначальному( необработанному) виду
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    fault = field.reset();
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

    fault = build();
    return fault; // Возвращает значение корректности выполнения метода
}

errtype AlgoBellman::build() {
    // Описание : Подготовка всех атрибутов алгоритма к последующей обработке и построению пути
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    // Удаление предыдущего списка ребер
    edges.clear();

    // Удаление предыдущих данных алгоритма
    if( dist != nullptr) delete [] dist;
    if( parents != nullptr) delete [] parents;

    // Обязательное использование версии базового класса данного метода после удаления всех страых данных
    fault = Algo::build();
    if( fault) return fault;

    // Создание нового списка ребер
    int xi, yi, xj, yj;
    ST tmpState;

    for( int i = 0; i < n; i++) {
        for( int j = 0; j < n; j++) { 
            fault = getGraphX( xi, i);  
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
            fault = getGraphY( yi, i);  
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
            fault = getGraphX( xj, j);  
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
            fault = getGraphY( yj, j);  
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

            field.getCellState( xj, yj, tmpState);

            // Если не рассматривается одна и та же клетка, и данная клетка не является (OBSTACLE)
            if( i != j && tmpState.code != OBSTACLE.code) {
                // Если достижима справа
                if( (yi == yj) && (xi+1 == xj) ) edges.push_back( {i, j, 1});
                // Если достижима слева
                else if( (yi == yj) && (xi-1 == xj) ) edges.push_back( {i, j, 1});
                // Если достижима сверху
                else if( (yi+1 == yj) && (xi == xj) ) edges.push_back( {i, j, 1});
                // Если достижима снизу
                else if( (yi-1 == yj) && (xi == xj) ) edges.push_back( {i, j, 1});
            }
        }
    }

    // Новые данные алгоримта
    dist = new int [n];
    parents = new int [n];
    for( int i = 0; i < n; i++) {
        // Мин расстояния до вершин от начальной вершины
        dist[i] = INF;
        if( i == startVert) dist[i] = 0; // До начальной вершины равно 0

        // Массив предшествующих вершин для построения минимального пути до них
        parents[i] = -1;
    }

    return fault; // Возвращает значение корректности выполнения метода
}
// -- Класс алгоритма Беллмона-Форда - (AlgoBellman)

// ++ Класс доски, ведущий учет за выполнением алгоритма и всех процессов на доске - (Desk)  
class Desk {
protected:
    int h; // Высота доски
    int w; // Ширина доски
    Field field; // Внутренняя сетка
    Algo* pAlgo; // Указатель на динамически созданный обьект алогритма

    CELLNSTARR nCells; // Массив значений количества клеток сетки с каждым из фактических состояний

public:
    Desk(); // Конструктор
    ~Desk(); // Деструктор

    errtype set( const Desk&); // Определяет этот обьект класса доски на основе другого обьекта
    errtype resize( int, int); // Изменение размеров доски и внутренней сетки
    errtype setCellState( int, int, ST); // Определяет состояние указанной клетки доски (внутренней сетки)
    errtype getCellState( int, int, ST&) const; // Возвращает состояние указанной клетки доски (внутренней сетки) через ссылку
    errtype reset(); // Приводит доску к изначальному( необработанному) виду

    errtype chooseAlgo( idtype); // Выбор алгоритма
    bool isValid(); // Возвращение логического значения к условию - правильно ли построена сетка для ее обработки алгоритмом
    errtype stepProcess(); // Осуществление шага в процессе обработки сетки алгоритмом
    bool isFinishedProcess(); // Возвращает логическое значение к условию - закончен ли процесс обработки сетки алгоритмом
    errtype stepBuildPath(); // Осуществление шага в процессе построения пути в сетке
    bool isFinishedBuildPath(); // озвращает логическое значение к условию - закончен ли процесс построения пути в сетке

    errtype getHeight( int&) const; // Возвращает высоту доски через ссылку
    errtype getWidth( int&) const; // Возвращает ширину доски через ссылку
    errtype getField( Field&) const; // Возвращает копию внутренней сетки через ссылку
    errtype getNCells( int&, ST) const; // Возвращает количество подсчитанных клеток с указанным состоянием через ссылку
    errtype getAlgoName( std::string&) const; // Возвращает название алгоритма через ссылку
    errtype getAlgoComplexity( std::string&) const; // Возвращает вычислительную сложность алгоритма через ссылку
    errtype getNIter( int&) const; // Возвращает количество выполенных итераций для нахождения пути (но не его построения) в сетке через ссылку
    errtype getPathLength( int&) const; // Возвращает длину найденного кратчайшего пути от начальной до конечной клетки в сетке через ссылку

private:
    errtype updateNCells(); // Обновить значения количества клеток с каждым из фактических состояний
};

Desk::Desk() {
    // Описание : Конструктор

    h = MIN_FIELD_H;
    w = MIN_FIELD_W;
    pAlgo = nullptr;
    chooseAlgo( ALGO_DEFAULT.code);

    updateNCells();
}

Desk::~Desk() {
    // Описание : Деструктор

    if( pAlgo != nullptr)
        delete pAlgo;
}

errtype Desk::set( const Desk& _desk) {
    // Описание : Определяет этот обьект класса доски на основе другого обьекта
    // Аргументы : 
    //      _desk - ссылка на другую доску
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    h = _desk.h;
    w = _desk.w;

    fault = field.set( _desk.field);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

    idtype code;
    fault = _desk.pAlgo->getCode( code);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
    fault = chooseAlgo( code);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
    
    fault = updateNCells();
    return fault; // Возвращает значение корректности выполнения метода
}

errtype Desk::resize( int _w, int _h) {
    // Описание : Изменение размеров доски и внутренней сетки
    // Аргументы : 
    //      _w - новая ширина доски
    //      _h - новая высота доски
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    fault = field.resize( _w, _h);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

    fault = pAlgo->init( field);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

    w = _w;
    h = _h;
    fault = updateNCells();
    return fault; // Возвращает значение корректности выполнения метода
}

errtype Desk::setCellState( int x, int y, ST _state) {
    // Описание : Определяет состояние указанной клетки доски (внутренней сетки)
    // Аргументы : 
    //      x - абцисса клетки на сетке
    //      y - ордината клетки на сетке
    //      _state - присваиваемое клетке состояние
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    ST state;
    fault = field.getCellState( x, y, state);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

    fault = field.setCellState( x, y, _state);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

    fault = pAlgo->init( field);
    if(fault) return fault; // Возвращает значение корректности выполнения метода

    nCells[state.code]--;
    nCells[_state.code]++;
    return fault; // Возвращает значение корректности выполнения метода
}

errtype Desk::getCellState( int x, int y, ST& _state) const { 
    // Описание : Возвращает состояние указанной клетки доски (внутренней сетки) через ссылку
    // Аргументы : 
    //      x - абцисса клетки на сетке
    //      y - ордината клетки на сетке
    //      _state - ссылка для возвращаемого состояния указанной клетки
    // Возвращает : Значение корректности выполнения метода

    // Возвращает значение корректности выполнения др функции
    return field.getCellState(x, y, _state); 
}

errtype Desk::reset() { 
    // Описание : Приводит доску к изначальному( необработанному) виду
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода
    
    fault = field.reset();
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

    fault = pAlgo->reset();
    return fault; // Возвращает значение корректности выполнения метода
}

errtype Desk::chooseAlgo( idtype code) {
    // Описание : Выбор алгоритма
    // Аргументы : 
    //      code - идентификационный код указанного алгоритма
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода
    
    if( code == ALGO_FLOYD.code) {
        delete pAlgo;
        pAlgo = new AlgoFloyd;
    }
    else if( code == ALGO_DEIKSTRA.code) {
        delete pAlgo;
        pAlgo = new AlgoDeikstra;
    }
    else if(code == ALGO_BELLMAN.code) {
        delete pAlgo;
        pAlgo = new AlgoBellman;
    }
    else
        return 1; // Если не было найдено алгоритма с данным кодом, озвращает Err

    fault = pAlgo->init( field);
    return fault; // Возвращает значение корректности выполнения метода
}

bool Desk::isValid() {
    // Описание : Возвращение логического значения к условию - правильно ли построена сетка для ее обработки алгоритмом
    // Возвращает : Логическое значение выполнения или невыполнения описанного условия

    // Правила:
    // 1) На доске должно быть обязательное количество начальных клеток, равное (START_N)
    // 2) На доске должно быть обязательное количество конечных клеток, равное (FINISH_N)
    return (nCells[START.code] == START_N && nCells[FINISH.code] == FINISH_N);
}

errtype Desk::stepProcess() {
    // Описание : Осуществление шага в процессе обработки сетки алгоритмом
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    fault = pAlgo->stepProcess();
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
    fault = pAlgo->getField( field);
    return fault; // Возвращает значение корректности выполнения метода
}

bool Desk::isFinishedProcess() { 
    // Описание :  Возвращает логическое значение к условию - закончен ли процесс обработки сетки алгоритмом
    // Возвращает : Логическое значение выполнения или невыполнения описанного условия
    
    // Возвращает значение от др функции
    return pAlgo->isFinishedProcess(); 
}

errtype Desk::stepBuildPath() {
    // Описание : Осуществление шага в процессе построения пути в сетке
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    fault = pAlgo->stepBuildPath();
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
    fault = pAlgo->getField( field);
    return fault; // Возвращает значение корректности выполнения метода
}

bool Desk::isFinishedBuildPath() { 
    // Описание :  Возвращает логическое значение к условию - закончен ли процесс построения пути в сетке
    // Возвращает : Логическое значение выполнения или невыполнения описанного условия

    // Возвращает значение от др функции
    return pAlgo->isFinishedBuildPath(); 
}

errtype Desk::getHeight( int& _h) const {
    // Описание : Возвращает высоту доски через ссылку
    // Аргументы : 
    //      _h - ссылка для возвращаемого значения высоты
    // Возвращает : Значение корректности выполнения метода

    _h = h;
    return 0; // Возвращает значение о корректном выполнении метода
}

errtype Desk::getWidth( int& _w) const {
    // Описание : Возвращает ширину доски через ссылку
    // Аргументы : 
    //      _w - ссылка для возвращаемого значения высоты
    // Возвращает : Значение корректности выполнения метода

    _w = w;
    return 0; // Возвращает значение о корректном выполнении метода
}

errtype Desk::getField( Field& _field) const {
    // Описание : Возвращает копию внутренней сетки через ссылку
    // Аргументы : 
    //      _field - ссылка для возвращаемой копии внутренней сетки
    // Возвращает : Значение корректности выполнения метода

    // Возвращает значение корректности выполнения др функции
    return _field.set(field);
}

errtype Desk::getNCells( int& _nCells, ST _state) const {
    // Описание : Возвращает количество подсчитанных клеток с указанным состоянием через ссылку
    // Аргументы : 
    //      _nCells - ссылка для возвращаемого значения количества клеток в сетке с указанным состоянием
    //      _state - указанное состояние клетки
    // Возвращает : Значение корректности выполнения метода

    _nCells = nCells[_state.code];
    return 0; // Возвращает значение о корректном выполнении метода
}

errtype Desk::getAlgoName( std::string& _name) const {
    // Описание : Возвращает название алгоритма через ссылку
    // Аргументы : 
    //      _name - ссылка для возвращаемого названия алгоритма
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода
    
    if( pAlgo == nullptr) return 1; // Если алгоритм не был выбран, возвращает Err
    fault = pAlgo->getName( _name);
    return fault; // Возвращает значение корректности выполнения метода
}

errtype Desk::getAlgoComplexity( std::string& _complexity) const {
    // Описание : Возвращает вычислительную сложность алгоритма через ссылку
    // Аргументы : 
    //      _complexity - ссылка для возвращаемого описания вычислительной сложности алгоритма
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода
    
    if( pAlgo == nullptr) return 1; // Если алгоритм не был выбран, возвращает Err
    fault = pAlgo->getComplexity( _complexity);
    return fault; // Возвращает значение корректности выполнения метода
}

errtype Desk::getNIter( int& n) const { 
    // Описание : Возвращает количество выполенных итераций для нахождения пути (но не его построения) в сетке через ссылку
    // Аргументы : 
    //      n - ссылка для возвращаемого значения количества выполненных итераций алгоритма для поиска пути
    // Возвращает : Значение корректности выполнения метода

    // Возвращает значение корректности выполнения др функции
    return pAlgo->getNIter(n); 
}

errtype Desk::getPathLength( int& l) const { 
    // Описание : Возвращает количество выполенных итераций для нахождения пути (но не его построения) в сетке через ссылку
    // Аргументы : 
    //      l - ссылка для возвращаемой длины найденного кратчайшего пути 
    // Возвращает : Значение корректности выполнения метода

    // Возвращает значение корректности выполнения др функции
    return pAlgo->getPathLength( l); 
}

errtype Desk::updateNCells() {
    // Описание : Обновить значения количества клеток с каждым из фактических состояний
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода
    
    for( int i = 0; i < ST_N; i++)
        nCells[i] = 0;

    ST state;
    for( int y = 0; y < h; y++) {
        for( int x = 0; x < w; x++) {
            fault = field.getCellState( x, y, state);
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

            nCells[state.code]++;
        }
    }

    return fault; // Возвращает значение корректности выполнения метода
}
// -- Класс доски, ведущий учет за выполнением алгоритма и всех процессов на доске - (Desk)s

// ++ Класс кисти - (Pen)
class Pen {
protected:
    ST drawState;
    
    // Координаты предыдущего поставленного кистью (START)
    int prevStartX;
    int prevStartY;
    // Координаты предыдущего поставленного кистью (FINISH)
    int prevFinishX;
    int prevFinishY;

public:
    Pen(); // Конструктор

    errtype draw( int, int, Desk&); // Присвоить состоянию указанной клетки сохранненое состояние кисти на указанной доске
    errtype setDrawState( ST); // Определить состояние, которым "окрашивает" кисть клетки
    errtype reset(); // Забывает всю информацию о предыдущих поставленных кистью клетках
    
    errtype getDrawState( ST&) const; // Возвращает состояние, которым кисть "окрашивает" клетки, через ссылку
};

Pen::Pen() {
    // Описание: Конструктор

    drawState = OBSTACLE;

    prevStartX = -1;
    prevStartY = -1;

    prevFinishX = -1;
    prevFinishY = -1;
}

errtype Pen::draw( int x, int y, Desk& desk) {
    // Описание : Присвоить состоянию указанной клетки сохранненое состояние кисти на указанной доске
    // Аргументы : 
    //      x - абцисса клетки на сетке
    //      y - ордината клетки на сетке
    //      desk - ссылка доски, на которой будут производится все изменения
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    // Правила: 
    // 1. Кисть стирает предыдущий поставленный (START)
    // 2. Кисть стирает предыдущий поставленный (FINISH)
    // 3. Когда состояние, используемое для закрашивания (drawState),
    // совпадает с состоянием указанной клетки (x, y), то клетка "стирается" - определяется как (EMPTY)
    // 4. Если правило 3 не рассматривается, кисть "закрашивает" клетки в drawState

    // Получение размеров доски
    int h;
    fault = desk.getHeight( h);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
    int w;
    fault = desk.getWidth( w);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

    if( y < 0 && y >= h)    return 1; // Если клетка с данной ординатой не лежит внутри доски, возвращает Err 
    if( x < 0 && x >= w)    return 1; // Если клетка с данной абциссой не лежит внутри доски, возвращает Err

    ST curState;
    fault = desk.getCellState( x, y, curState);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
    
    // Правило 1 (START)
    if( drawState.code == START.code) {
        // Если (START) поставлен кистью уже не в первый раз
        if( prevStartX >= 0 && prevStartX < w && prevStartY >= 0 && prevStartY < h) {
            fault = desk.setCellState( prevStartX, prevStartY, EMPTY); // Стереть предыдущий (START)
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
        }
        fault = desk.setCellState( x, y, START); // Поставить новый (START)
        if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

        // Сохранить координаты нынешнего (START) в координаты предыдущего
        prevStartX = x;
        prevStartY = y;
    }

    // Правило 2 (FINISH)
    else if( drawState.code == FINISH.code) {
        // Если (FINISH) поставлен кистью уже не в первый раз
        if( prevFinishX >= 0 && prevFinishX < w && prevFinishY >= 0 && prevFinishY < h) {
            fault = desk.setCellState( prevFinishX, prevFinishY, EMPTY); // Стереть предыдущий (FINISH)
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
        }
        fault = desk.setCellState( x, y, FINISH); // Поставить новый (FINISH)
        if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

        // Сохранить координаты нынешнего (FINISH) в координаты предыдущего
        prevFinishX = x;
        prevFinishY = y;
    }
    else {
        // Правило 4
        if( curState.code != drawState.code)
            fault = desk.setCellState( x, y, drawState); // Закрашивает
        // Правило 3
        else 
            fault = desk.setCellState( x, y, EMPTY); // Стирает

        if( fault) return fault; // В случае некорректного выполнения одной из двух предыдущих строк кода, возвращает Err
    }

    return fault; // Возвращает значение корректности выполнения метода
}

errtype Pen::setDrawState( ST _drawState) {
    // Описание : пределить состояние, которым "окрашивает" кисть клетки
    // Аргументы : 
    //      _drawState - присваиваемое состояние
    
    // Если указанное состояние не входит в список состояний, 
    // которые может использовать кисть
    if( _drawState.code < 0 || _drawState.code >= ST_DRAW_N) return 1; // Возвращает Err
    
    drawState = _drawState;

    return 0; // Возвращает значение о корректном выполнении метода
}

errtype Pen::reset() {
    // Описание : Забывает всю информацию о предыдущих поставленных кистью клетках
    // Возвращает : Значение корректности выполнения метода

    prevStartX = -1;
    prevStartY = -1;

    prevFinishX = -1;
    prevFinishY = -1;

    return 0; // Возвращает значение о корректном выполнении метода
}

errtype Pen::getDrawState( ST& _drawState) const {
    // Описание : Возвращает состояние, которым кисть "окрашивает" клетки, через ссылку
    // Аргументы : 
    //      _drawState - ссылка для возвращаемого состояния, которым кисть "окрашивает" клетки
    // Возвращает : Значение корректности выполнения метода

    _drawState = drawState;

    return 0; // Возвращает значение о корректном выполнении метода
}
// -- Класс кисти - (Pen)


// ++ Абстрактный класс отображения - (IView)
class IView {
public:
    virtual errtype show() {
        // Описание : Метод отображения
        // Возвращает : Значение корректности выполнения метода

        return 0; // Возвращает значение о корректном выполнении метода
    }
};
// -- Абстрактный класс отображения - (IView)


// ++ Класс клетки с возможностью ее отображения - (ICell)
class ICell : public Cell, public IView {
public:
    errtype show(); // Метод отображения
};

errtype ICell::show() {
    // Описание : Метод отображения
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    // Output : show cell
    std::setlocale( LC_ALL, "C");
    HANDLE h = GetStdHandle( STD_OUTPUT_HANDLE);
    SetConsoleTextAttribute( h, state.colour);
    std::cout << char( 219) << char(219);
    SetConsoleTextAttribute( h, WHITE);
    std::setlocale( LC_ALL, "Russian");

    return fault; // Возвращает значение корректности выполнения метода
}
// -- Класс клетки с возможностью ее отображения - (ICell)


// ++ Класс сетки с возможностью ее отображения - (IField)
class IField : public Field, public IView {
public:
    errtype show(); // Метод отображения
};

errtype IField::show() {
    // Описание : Метод отображения
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    std::setlocale(LC_ALL, "Russian");

    ICell cell;
    for( int i = 2*BORDER_SIZE+h-1; i >= 0; i--) {
        for( int j = 0; j < 2*BORDER_SIZE+w; j++) {
            fault = cell.set( cells[i][j]);
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
            fault = cell.show();
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
        }
        std::cout << "\n";
    }

    return fault; // Возвращает значение корректности выполнения метода
}
// -- Класс сетки с возможностью ее отображения - (IField)


// ++ Класс доски с возможностью ее отображения - (IDesk)
class IDesk : public Desk, public IView {
public:
    errtype show();
};

errtype IDesk::show() {
    errtype fault = 0; // Значение корректности выполнения метода

    IField iField;
    fault = iField.set( field);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

    fault = iField.show();
    return fault; // Возвращает значение корректности выполнения метода
}
// -- Класс доски с возможностью ее отображения - (IDesk)


// ++ Класс кисти с возможностью ее отображения - (IPen)
class IPen : public Pen, public IView {
public:
    errtype show() {
        return 0; // Возвращает значение о корректном выполнении метода
    }
};
// -- Класс кисти с возможностью ее отображения - (IPen)


// ++ Класс рабочего пространства (окна) - (ABoard)
class ABoard {
protected:
    std::queue <QUERY> que; // Очередь запросов
    QUERY lastQuery; // Последний обработанный запрос

    IPen pen; // Кисть
    // Относительные координаты кисти на доске
    int penDeskX;
    int penDeskY; 

    IDesk desk; // Главная доска
    char isAlgoLaunched; // Логическое значение к условию - запущено ли выполнение алгоритма

public:
    ABoard(); // Конструктор

    errtype addQuery( QUERY); // Добавить запрос в конец очереди
    bool isQueryListEmpty(); // Возвращает логическое значение к условию - пустая ли очередь запросов
    errtype processQuery(); // Обработать первый запрос в очереди
    errtype clearQueryList(); // Очищает очередь запросов

    errtype getLastQuery( QUERY&); // Возвравщает последний обработанный запрос в очереди

private:
    errtype launch( QUERY&); // Запускает работу алгоритма поиска кратчайшего пути на сетке по запросу
    errtype step( QUERY&); // Осуществляет шаг в алгоритме поиска кратчайшего пути на сетке по запросу
    errtype reset(); // Принудительно возвращает атрибуты рабочего пространства к изначальному( необработанному) виду по запросу
    errtype resize( QUERY&); // Изменяет размер доски внутри рабочего пространства по запросу
    errtype editPenState( QUERY&); // Изменяет состояние кисти, которым она "окрашивает" клетки доски, по запросу
    errtype editPenCoords( QUERY&); // Изменяет положение кисти на доске по запросу
    errtype drawByPen(); // "Закрашивает" кистью клетку доски на которой она находится
    errtype draw( QUERY&); // "Закрашивает" кистью указанную в запросе клетку доски в указанное в запросе состояние
    errtype chooseAlgo( QUERY&); // Выбирает алгоритм поиска кратчайшего пути на сетке по запросу
    
    errtype showDesk(); // Отображает внутреннюю доску
    errtype showAlgo(); // Отображает информацию об алгоритме
    errtype showAlgoState(); // Отображает информацию о выполнении алгоритма
    errtype showResult(); // Отображает результаты работы алгоритма поиска кратчайшего пути на сетке

    errtype sleep( QUERY&); // Создает задержку в указанное в запросе время
};

ABoard::ABoard() { 
    // Описание : Конструктор

    penDeskX = -1;
    penDeskY = -1;

    isAlgoLaunched = 0; 
}

errtype ABoard::addQuery( QUERY q) {
    // Описание : Добавить запрос в конец очереди
    // Аргументы : 
    //      q - запрос к действию в рабочем пространстве
    // Возвращает : Значение корректности выполнения метода

    que.push( q);
    return 0; // Возвращает значение о корректном выполнении метода
}

bool ABoard::isQueryListEmpty() { 
    // Описание : Возвращает логическое значение к условию - пустая ли очередь запросов
    // Возвращает : Логическое значение выполнения или невыполнения описанного условия

    // Возвращает значение от др функции
    return que.empty(); 
}

errtype ABoard::processQuery() {
    // Описание : Обработать первый запрос в очереди
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    // Бездействовать, в случае пустой очереди запросов
    if( que.empty())
        return 0; // Возвращает значение о корректном выполнении метода

    // Читает первый в очереди запрос
    QUERY q = que.front();
    lastQuery = q;
    que.pop();

    // В зависимости от флага запроса выполняется соответствующий метод
    switch( q.flag) {
        case F_LAUNCH: {
            fault = launch( q);
        } break;

        case F_STEP: {
            fault = step( q);
        } break;

        case F_RESET: {
            fault = reset();
        } break;

        case F_RESIZE: {
            fault = resize( q);
        } break;

        case F_PEN_STATE: {
            fault = editPenState( q);
        } break;

        case F_PEN_COORDS: {
            fault = editPenCoords( q);
        } break;

        case F_PEN_DRAW: {
            fault = drawByPen();
        } break;

        case F_DRAW: {
            fault = draw( q);
        } break;

        case F_ALGO: { 
            fault = chooseAlgo( q);
        } break;

        case F_SHOW_DESK: {
            fault = showDesk();
        } break;

        case F_SHOW_ALGO: {
            fault = showAlgo();
        } break;

        case F_SHOW_ALGO_STATE: {
            fault = showAlgoState();
        } break;

        case F_SHOW_RESULT: {
            fault = showResult();
        } break;

        case F_SLEEP: {
            fault = sleep( q);
        } break;

        default: 
            return 1; // В случае, если был получен запрос на несуществующее действие, возвращает Err
    }

    return fault; // Возвращает значение корректности выполнения метода
}

errtype ABoard::clearQueryList() {
    // Описание : Очищает очередь запросов
    // Возвращает : Значение корректности выполнения метода

    while( !que.empty()) que.pop();
    return 0; // Возвращает значение о корректном выполнении метода
}

errtype ABoard::getLastQuery( QUERY& q) {
    // Описание : Возвравщает последний обработанный запрос в очереди
    // Аргументы : 
    //      q - спецификации запроса
    // Возвращает : Значение корректности выполнения метода

    q = lastQuery;
    return 0; // Возвращает значение о корректном выполнении метода
}

errtype ABoard::launch( QUERY& q) {
    // Описание : Запускает работу алгоритма поиска кратчайшего пути на сетке по запросу
    // Аргументы : 
    //      q - спецификации запроса
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    fault = desk.reset();
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

    // Если доска была правильно составлена
    if( desk.isValid()) {
        isAlgoLaunched = 1;

        fault = addQuery( {F_STEP});
        if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
    } 
    else 
        return 1; // Иначе, возвращает Err

    return fault; // Возвращает значение корректности выполнения метода
}

errtype ABoard::step( QUERY& q) {
    // Описание : Осуществляет шаг в алгоритме поиска кратчайшего пути на сетке по запросу
    // Аргументы : 
    //      q - спецификации запроса
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    if( isAlgoLaunched) {
        // Процесс обработки
        if( !desk.isFinishedProcess()) {
            fault = desk.stepProcess();
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
            
            // Запросы на отображение результатов выполнения шага алгоритма
            fault = addQuery( {F_SHOW_ALGO_STATE});
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
            fault = addQuery( {F_SHOW_DESK});
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
            // Запрос на выполнение следующего шага процесса обработки
            fault = addQuery( {F_STEP});
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
        }
        // Процесс построения пути
        else if( !desk.isFinishedBuildPath()) {
            fault = desk.stepBuildPath();
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
            // Запрос на отображение результатов выполнения шага в построении пути на сетке
            fault = addQuery( {F_SHOW_ALGO_STATE});
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
            
            // Если построение пути не завершено, сделать запрос на отображение доски
            if( !desk.isFinishedBuildPath()) {
                // Запрос на отображение доски
                fault = addQuery( {F_SHOW_DESK});
                if(fault) return fault; // Возвращает значение корректности выполнения метода
            }
            // Запрос на осуществление следующего шага в построении пути на сетке
            fault = addQuery( {F_STEP});
            if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
        } 

        // Если алгоритм завершен
        else {
            isAlgoLaunched = 0;

            // Запрос на отображение конечных результатов
            fault = addQuery( {F_SHOW_RESULT});
            if( fault) return fault; // Возвращает значение корректности выполнения метода
            // Запрос на принудительное возвращение атрибутов к изначальному( необработанному) виду
            fault = addQuery( {F_RESET});
            if( fault) return fault; // Возвращает значение корректности выполнения метода
        }

        // Запрос на задержку в течение (SHOW_STEP_DEALY)
        fault = addQuery( {F_SLEEP, 0, SHOW_STEP_DELAY});
    }

    return fault; // Возвращает значение корректности выполнения метода
}

errtype ABoard::reset() { 
    // Описание : Принудительно возвращает атрибуты рабочего пространства к изначальному( необработанному) виду по запросу
    // Возвращает : Значение корректности выполнения метода

    // Возвращает значение корректности выполнения др функции
    return desk.reset(); 
}

errtype ABoard::resize( QUERY& q) {
    // Описание : Изменяет размер доски внутри рабочего пространства по запросу
    // Аргументы : 
    //      q - спецификации запроса
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    fault = desk.resize( q.val1, q.val2);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
    fault = pen.reset();
    return fault; // Возвращает значение корректности выполнения метода
}

errtype ABoard::editPenState( QUERY& q) { 
    // Описание : Изменяет состояние кисти, которым она "окрашивает" клетки доски, по запросу
    // Аргументы : 
    //      q - спецификации запроса
    // Возвращает : Значение корректности выполнения метода
    
    // Возвращает значение корректности выполнения др функции
    return pen.setDrawState( STATES[q.code]); 
}

errtype ABoard::editPenCoords( QUERY& q) {
    // Описание : Изменяет положение кисти на доске по запросу
    // Аргументы : 
    //      q - спецификации запроса
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    int h;
    fault = desk.getHeight( h);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
    int w;
    fault = desk.getWidth( w);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

    if( q.val1 < 0 || q.val1 >= w) return 1; // Если клетка с данной абциссой не лежит внутри доступной зоны сетки, возвращает Err
    if( q.val2 < 0 || q.val2 >= h) return 1; // Если клетка с данной ординатой не лежит внутри доступной зоны сетки, возвращает Err

    penDeskX = q.val1;
    penDeskY = q.val2;

    return fault; // Возвращает значение корректности выполнения метода
}

errtype ABoard::drawByPen() {
    // Описание : "Закрашивает" кистью клетку доски на которой она находится
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    if( !isAlgoLaunched)
        fault = pen.draw( penDeskX, penDeskY, desk);
    return fault; // Возвращает значение корректности выполнения метода
}

errtype ABoard::draw( QUERY& q) {
    // Описание : "Закрашивает" кистью указанную в запросе клетку доски в указанное в запросе состояние
    // Аргументы : 
    //      q - спецификации запроса
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    fault = pen.setDrawState( STATES[q.code]);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

    int h;
    fault = desk.getHeight( h);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
    int w;
    fault = desk.getWidth( w);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

    if( q.val1 < 0 || q.val1 >= w) return 1; // Если клетка с данной абциссой не лежит внутри доступной зоны сетки, возвращает Err
    if( q.val2 < 0 || q.val2 >= h) return 1; // Если клетка с данной ординатой не лежит внутри доступной зоны сетки, возвращает Err

    penDeskX = q.val1;
    penDeskY = q.val2;

    if( !isAlgoLaunched) {
        fault = pen.draw( penDeskX, penDeskY, desk);
        if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
    }

    return fault; // Возвращает значение корректности выполнения метода
}

errtype ABoard::chooseAlgo( QUERY& q) {
    // Описание : Выбирает алгоритм поиска кратчайшего пути на сетке по запросу
    // Аргументы : 
    //      q - спецификации запроса
    // Возвращает : Значение корректности выполнения метода

    // Возвращает значение корректности выполнения др функции
    return desk.chooseAlgo(q.code);
}

errtype ABoard::showDesk() {
    // Описание : Отображает внутреннюю доску
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    std::setlocale( LC_ALL, "Russian");

    int h;
    fault = desk.getHeight( h);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
    int w;
    fault = desk.getWidth( w);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
    
    std::cout << "Сетка размером " << h << "*" << w << " (высота*ширина) : \n";
    IDesk iDesk;
    iDesk.set( desk);
    fault = iDesk.show();

    return fault; // Возвращает значение корректности выполнения метода
}

errtype ABoard::showAlgo() {
    // Описание : Отображает информацию об алгоритме
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    std::setlocale(LC_ALL, "Russian");

    std::string algoName;
    fault = desk.getAlgoName( algoName);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
    std::string algoComp;
    fault = desk.getAlgoComplexity( algoComp);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
    std::cout << "Используется : " << algoName << ", с вычислительной сложностью\t" << algoComp << "\n";

    return fault; // Возвращает значение корректности выполнения метода
}

errtype ABoard::showAlgoState() {
    // Описание : Отображает информацию о выполнении алгоритма
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    std::setlocale( LC_ALL, "Russian");
    std::cout << "\n";

    if( isAlgoLaunched) {
        if( !desk.isFinishedProcess())
            std::cout << "Алгоритм запущен на этапе : обработка сетки";
        else if( !desk.isFinishedBuildPath())
            std::cout << "Алгоритм запущен на этапе : отрисовка пути";
        else
            std::cout << "Выполнение алгоритма завершено";
        std::cout << "\n";
    } 

    else
        std::cout << "Алгоритм не запущен\n";

    return fault; // Возвращает значение корректности выполнения метода
}

errtype ABoard::showResult() {
    // Описание : Отображает результаты работы алгоритма поиска кратчайшего пути на сетке
    // Возвращает : Значение корректности выполнения метода

    errtype fault = 0; // Значение корректности выполнения метода

    std::setlocale( LC_ALL, "Russian");
    std::cout << "\n";

    std::string algoName;
    fault = desk.getAlgoName( algoName);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
    std::string algoComp;
    fault = desk.getAlgoComplexity( algoComp);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
    std::cout << "Для поиска пути использовался : " << algoName << ", с вычислительной сложностью\t" << algoComp << "\n";

    int nIter;
    fault = desk.getNIter( nIter);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err
    std::cout << "Количество выполненных итераций : " << nIter << "\n";

    int pathLength;
    fault = desk.getPathLength( pathLength);
    if( fault) return fault; // В случае некорректного выполнения предыдущей строки кода, возвращает Err

    if( pathLength == INF) std::cout << "Путь от начальной до конечной точки не был найден\n";
    else std::cout << "Длина найденного кратчайшего пути : " << pathLength << "\n";

    return fault; // Возвращает значение корректности выполнения метода
}

errtype ABoard::sleep( QUERY& q) {
    // Описание : Создает задержку в указанное в запросе время
    // Аргументы : 
    //      q - спецификации запроса
    // Возвращает : Значение корректности выполнения метода

    Sleep( q.val1);
    return 0; // Возвращает значение о корректном выполнении метода
}
// -- Класс рабочего пространства (окна) - (ABoard)


// ++ Функция main
int main() {
    std::setlocale( LC_ALL, "Russian");
    std::cout << "Начало программы\n\n";
    ABoard board;
    board.addQuery( {F_SHOW_ALGO});
    board.processQuery();
    board.addQuery( {F_SHOW_DESK}); 
    board.processQuery();

    while( true) {
        std::cout << "\n----------------------------------------------------------------------------\n";
        std::cout << "Команды для взаимодействия с рабочим пространством :\n";
        std::cout << A_LAUNCH   << " - \'LAUNCH\'   команда запуска визуализации работы выбранного алгоритма\n";
        std::cout << A_NEW      << " - \'NEW\'      команда создания новой сетки\n";
        std::cout << A_TEMPLATE << " - \'TEMPLATE\' команда сборки сетки по заготовленному примеру\n";
        std::cout << A_PAINT    << " - \'PAINT\'    команда изменения состояния выбранной клетки\n";
        std::cout << A_ALGO     << " - \'ALGO\'     команда выбора алгоритма\n";
        std::cout << A_ABOUT    << " - \'ABOUT\'    команда обращения к информации о программе\n";
        std::cout << A_EXIT     << " - \'EXIT\'     команда выхода из программы\n";
        std::cout << "> Введите код выбранной команды : ";

        // Ввод : код выбранной команды
        int command_code;
        std::cin >> command_code;
        APP_MESSAGE choice = APP_MESSAGE( command_code);
        std::cout << "\n";

        switch( choice) {
            case A_LAUNCH: {
                // Запуск визуализации работы алгоритма поиска кратчайшего пути на сетке
                std::setlocale( LC_ALL, "Russian");

                std::cout << "Начало визуализации работы алгоритма поиска кратчайшего пути на сетке\n";
                board.addQuery( {F_LAUNCH});
            } break;

            case A_NEW: {
                // Создание новой доски

                // Ввод : высота
                unsigned int h;
                std::cout << "> Введите значение высоты новой сетки (h) : ";
                std::cin >> h;
                if( h < MIN_FIELD_H || h > MAX_FIELD_H) {
                    std::cout << "Err: высота должна быть в диапазоне (" << MIN_FIELD_H << " <= h <= " << MAX_FIELD_H << ")\n";
                    break;
                }
                // Ввод : ширина
                unsigned int w;
                std::cout << "> Введите значение ширины новой сетки (w) : ";
                std::cin >> w;
                if( w < MIN_FIELD_W || w > MAX_FIELD_W) {
                    std::cout << "Err: ширина должна быть в диапазоне (" << MIN_FIELD_W << " <= w <= " << MAX_FIELD_W << ")\n";
                    break;
                }

                // Отправить запрос на изменение размеров рабочего пространства
                board.addQuery( {F_RESIZE, 0, w, h});
                // Отправить запрос на отображение доски
                board.addQuery( {F_SHOW_DESK});
            } break;

            case A_TEMPLATE: {
                // Создание доски по заготовленному шаблону

                std::cout << "Создание сетки по заготовленному примеру\n";
                // Изменение размеров рабочего пространства
                board.addQuery( {F_RESIZE, 0, 18, 10});
                // Размещение начальной клетки
                board.addQuery( {F_DRAW, START.code, 2, 1});
                // Размещение конечной клетки
                board.addQuery( {F_DRAW, FINISH.code, 17, 5});
                // Размещение препятствий
                board.addQuery( {F_PEN_STATE, OBSTACLE.code});
                board.addQuery( {F_PEN_COORDS, 0, 3, 3});   board.addQuery( {F_PEN_DRAW});
                board.addQuery( {F_PEN_COORDS, 0, 3, 4});   board.addQuery( {F_PEN_DRAW});
                board.addQuery( {F_PEN_COORDS, 0, 3, 8});   board.addQuery( {F_PEN_DRAW});
                board.addQuery( {F_PEN_COORDS, 0, 3, 9});   board.addQuery( {F_PEN_DRAW}); 
                board.addQuery( {F_PEN_COORDS, 0, 4, 0});   board.addQuery( {F_PEN_DRAW});
                board.addQuery( {F_PEN_COORDS, 0, 4, 1});   board.addQuery( {F_PEN_DRAW});
                board.addQuery( {F_PEN_COORDS, 0, 4, 2});   board.addQuery( {F_PEN_DRAW});
                board.addQuery( {F_PEN_COORDS, 0, 4, 5});   board.addQuery( {F_PEN_DRAW});
                board.addQuery( {F_PEN_COORDS, 0, 4, 7});   board.addQuery( {F_PEN_DRAW});
                board.addQuery( {F_PEN_COORDS, 0, 7, 2});   board.addQuery( {F_PEN_DRAW});
                board.addQuery( {F_PEN_COORDS, 0, 8, 3});   board.addQuery( {F_PEN_DRAW});
                board.addQuery( {F_PEN_COORDS, 0, 8, 4});   board.addQuery( {F_PEN_DRAW});
                board.addQuery( {F_PEN_COORDS, 0, 9, 5});   board.addQuery( {F_PEN_DRAW});
                board.addQuery( {F_PEN_COORDS, 0, 9, 6});   board.addQuery( {F_PEN_DRAW});
                board.addQuery( {F_PEN_COORDS, 0, 9, 7});   board.addQuery( {F_PEN_DRAW});
                board.addQuery( {F_PEN_COORDS, 0, 9, 8});   board.addQuery( {F_PEN_DRAW});
                board.addQuery( {F_PEN_COORDS, 0, 9, 9});   board.addQuery( {F_PEN_DRAW});
                board.addQuery( {F_PEN_COORDS, 0, 11, 0});  board.addQuery( {F_PEN_DRAW});
                board.addQuery( {F_PEN_COORDS, 0, 11, 1});  board.addQuery( {F_PEN_DRAW});
                board.addQuery( {F_PEN_COORDS, 0, 11, 2});  board.addQuery( {F_PEN_DRAW});
                board.addQuery( {F_PEN_COORDS, 0, 12, 3});  board.addQuery( {F_PEN_DRAW});
                board.addQuery( {F_PEN_COORDS, 0, 12, 4});  board.addQuery( {F_PEN_DRAW});
                board.addQuery( {F_PEN_COORDS, 0, 12, 7});  board.addQuery( {F_PEN_DRAW});
                board.addQuery( {F_PEN_COORDS, 0, 12, 8});  board.addQuery( {F_PEN_DRAW});
                board.addQuery( {F_PEN_COORDS, 0, 12, 9});  board.addQuery( {F_PEN_DRAW});
                board.addQuery( {F_PEN_COORDS, 0, 13, 6});  board.addQuery( {F_PEN_DRAW});
                // Отправить запрос на отображение доски
                board.addQuery( {F_SHOW_DESK});
            } break;

            case A_PAINT: {
                // Изменение состояния определенной клетки; "закрашивание" определенной клетки

                std::cout << "Все возможные состояния клетки:\n";
                for( int i = 0; i < ST_DRAW_N; i++) {
                    ICell cell;
                    cell.setState( STATES[i]);
                    IView* p = &cell;

                    ST tmp;
                    cell.getState( tmp);
                    std::cout << tmp.code << " - Состояние клетки "; std::cout.width(8); std::cout << tmp.name << " будет отображен как :\t";
                    p->show();
                    std::cout << "\n";
                }

                // Ввод : новое состояние клетки
                std::cout << "> Введите код выбранного состояния : ";
                idtype code;
                std::cin >> code;

                bool check = false;
                for( int i = 0; i < ALGO_N && !check; i++) {
                    if( code == STATES[i].code)
                        check = true;
                }
                if( !check) {
                    std::cout << "Err: невозможно найти соответствующее состояние\n";
                    break;
                }

                // Ввод : координаты закрашиваемой клетки
                std::cout << "> Введите координаты закрашиваемой клетки (x, y) : ";
                unsigned int x;
                unsigned int y;
                std::cin >> x >> y;
                std::cout << "\n";

                // Отправить запрос на "закрашивание" выбранной клетки в выбранное состояние
                board.addQuery( {F_DRAW, code, x, y});
                // Отправить запрос на отображение доски
                board.addQuery( {F_SHOW_DESK});
            } break;

            case A_ALGO: {
                // Выбор алгоритма поиска кратчайшего пути

                std::cout << "Алгоритмы поиска наикратчайшего пути : \n";
                for(int i = 0; i < ALGO_N; i++) {
                    std::cout << ALGOPROPS[i].code << " - ";
                    std::cout.width( 25);
                    std::cout << ALGOPROPS[i].name << ";\t" << ALGOPROPS[i].complexity << "\n";
                }
                
                // Ввод : код выбранного алгоритма
                std::cout << "> Введите номер интересующего вас алгоритма : ";
                idtype code;
                std::cin >> code;
                std::cout << "\n";

                bool check = false;
                for( int i = 0; i < ALGO_N && !check; i++) {
                    if( code == ALGOPROPS[i].code)
                        check = true;
                }
                if( !check) {
                    std::cout << "Err: некорректный код алгоритма\n";
                    break;
                }

                // Отправить запрос на выбор алгоритма
                board.addQuery( {F_ALGO, code});
                // Отправить запрос на отображение выбранного алгоритма
                board.addQuery( {F_SHOW_ALGO, code});
            } break;

            case A_ABOUT: {
                // Информация о программе

                std::cout << "Проект:\n"
                          << "\"Визуализация работы алгоритмов поиска наикратчайшего пути\"\n\n"
                          << "Содержание:\n"
                          << "Программа для отображения и сравнения работы алгоритмов поиска наикратчайшего пути\n"
                          << "от указанных начальной и конечной точек на сетке. Программный интерфейс позволяет\n"
                          << "выбирать интересующий из предложенных алгоритмов поиска пути,\n"
                          << "изменять препятствия, положения начальной и конечной точек на сетке,\n"
                          << "и запускать визуализацию шагов выполнения алгоритма и процесса построения пути.\n"
                          << "Для улучшения качества работы с программой реализована возможность использования\n"
                          << "заготовленного примера сетки.\n\n"
                          << "Программа выполнена на языке С++.\n" 
                          << "UX, 2022.\n";
            } break;

            case A_EXIT: {
                // Конец программы
                std::cout << "Конец программы\n";
                return 0;
            }

            default: {
                // В случае неверного ввода комманды
                std::cout << "Err: некорректный код комманды\nДля взаимодействия с программой введите код команды из предложенного списка команд\n";
            } break;
        }

        errtype fault = 0; // Значение корректности выполнения метода
        std::cin.ignore();
        while( !fault && !board.isQueryListEmpty()) {
            fault = board.processQuery();
        }

        if( fault) {
            QUERY q;
            board.getLastQuery( q);
            std::cout << "Err: ошибка при попытке выполнить запрос (QUERY) c кодом флага " << q.flag << "\n";
            board.clearQueryList();
        }
    }

    return 0;
}
// -- Функция main
